<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#82B1FFFF"/>
    <title>Run Tracker</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.cyan-light_blue.min.css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto:300,400,500,700" type="text/css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/easytimer.js@4.6.0/dist/easytimer.min.js"></script>
</head>
<style>
.app_panel {
    height: 100vh;
    background: #343434;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: start;
    padding: 8px;
}
.mdl-button {
    width: 25vw;
}
#plot {
    width: 90vw;
    height: 30vh;
}
dialog {
    background: #343434;
    border-radius: 5px;
}
.material-icons {
    font-size: 38px;
}
.primary-run-info {
    align-items: center;
    width: 100%;
    display: flex;
    flex-direction: column;
}
.secondary-run-info {
    align-items: start;
}
.action-buttons {
    width: 100%;
    display: flex;
    flex-direction: row;
    justify-content: center;
}
.plot-actions-area {
    width: 100%;
    justify-content: center
}
</style>
<body>
      <div class="app_panel">
          <div class="primary-run-info">
              <h1 class="mdl-typography--display-4 mdl-color-text--white" id="distance">0</h1><h6 class="mdl-typography--title mdl-color-text--grey-600" id="unit">km</h6>
          </div>
          <div class="secondary-run-info">
              <h3 class="mdl-typography--display-2 mdl-color-text--white" id="time">00:00:00</h3>
              <h6 class="mdl-typography--title mdl-color-text--grey-600">Time</h6>
              <h3 class="mdl-typography--display-2 mdl-color-text--white" id="pace">00:00:00</h3>
              <h6 class="mdl-typography--title mdl-color-text--grey-600">Pace (not yet implemented)</h6>
          </div>
          <div class="plot-actions-area">
              <svg id="plot"></svg>
              <div class="action-buttons">
                  <button class="mdl-button mdl-js-button mdl-button--primary" id="startPauseButton">
                    <i class="material-icons">play_circle</i>
                  </button>
                  <button class="mdl-button mdl-js-button mdl-button--primary" id="stopButton">
                    <i class="material-icons">stop_circle</i>
                  </button>
                  <button class="mdl-button mdl-js-button mdl-button--primary" id="debug">
                    <i class="material-icons">bug_report</i>
                  </button>
                  <button class="mdl-button mdl-js-button mdl-button--icon mdl-button--colored" id="discard" disabled>
                    <i class="material-icons">delete_forever</i>
                  </button>
              </div>
          </div>
        </div>
</body>
<dialog id="dialog" class="mdl-dialog">
    <h4 id="dialog-title" class="mdl-dialog__title mdl-color-text--grey-400"></h4>
    <div id="dialog-content" class="mdl-dialog__content mdl-color-text--grey-400">
    </div>
    <div class="mdl-dialog__actions">
      <button id="dialog-confirm" type="button" class="mdl-button mdl-color-text--grey-300">Confirm</button>
      <button id="dialog-cancel" type="button" class="mdl-button close mdl-color-text--grey-300">Cancel</button>
    </div>
</dialog>
<script>

let dialogConfirmButton = document.querySelector('#dialog-confirm');
const dialogCancelButton = document.querySelector('#dialog-cancel');
const dialog = document.querySelector('#dialog');
const dialogTitle = document.querySelector('#dialog-title');
const dialogContent = document.querySelector('#dialog-content');
function hideDialog() {
    dialog.close();
    dialogTitle.innerHTML = '';
    dialogContent.innerHTML = '';
    dialogConfirmButton.replaceWith(dialogConfirmButton.cloneNode(true));
}

dialogCancelButton.addEventListener('click', hideDialog)

function createModal(title, contentHTML, confirmAction) {
    dialogConfirmButton = document.querySelector('#dialog-confirm');
    dialogTitle.textContent = title;
    dialogContent.innerHTML = contentHTML;
    dialogConfirmButton.addEventListener('click', () => {
        confirmAction();
        hideDialog();
    })
    dialog.showModal();
    console.log()
}




const timeDisplay = document.querySelector('#time');
const distanceDisplay = document.querySelector('#distance');

const timerInstance = new easytimer.Timer();
const positions = [];

timerInstance.addEventListener('secondsUpdated', () => {
    timeDisplay.textContent = timerInstance.getTimeValues().toString();
    if (timerInstance.getTimeValues().seconds % 5 === 0) {
        navigator.geolocation.getCurrentPosition(position => {
            const latestPosition = positions[positions.length - 1];
            if (latestPosition && latestPosition[0] === position.coords.latitude && latestPosition[1] === position.coords.longitude) {
                return;
            }
            positions.push([position.coords.latitude, position.coords.longitude]);
})

        if (positions.length >= 2) {
            const distance = calculateTotalDistance(positions, 'km')
            distanceDisplay.textContent = distance.toFixed(3);
            plotGpsCoordinatesToSvg(positions);
        }
    }
})

const startPauseButton = document.querySelector('#startPauseButton');
const stopButton = document.querySelector('#stopButton');
const discardRunButton = document.querySelector('#discard');
const debugButton = document.querySelector('#debug');


debugButton.addEventListener('click', () => {
    let coords = generateSmoothPath(40.730610, -73.935242, 30);
    plotGpsCoordinatesToSvg(coords);
    setTimeout(() => {
        let svg = document.getElementById("plot");
        if (!coords || coords.length === 0) return;
        while (svg.firstChild) {
            svg.removeChild(svg.firstChild);
         }
    }, 5000)

})

let running = false;
stopButton.disabled = !running;
startPauseButton.addEventListener('click', () => {
    if (!running) {
        if (timerInstance.getTotalTimeValues().secondTenths === 0) {
            positions.length = 0;
            navigator.geolocation.getCurrentPosition(position => {

                positions.push([position.coords.latitude, position.coords.longitude]);
            })
            discardRunButton.disabled = false;
        }
        timerInstance.start();
        startPauseButton.innerHTML = '<i class="material-icons">pause_circle</i>';
    } else {
        timerInstance.pause();
        startPauseButton.innerHTML = '<i class="material-icons">play_circle</i>';
    }
    running = !running;
    stopButton.disabled = running;
})
stopButton.addEventListener('click', () => {
    // saving run details logic
    // haven't decided if i'll add a db or not
})

function resetRun() {
        timeDisplay.textContent = '00:00:00';
        distanceDisplay.textContent = '0';
        positions.length = 0;
        timerInstance.stop();
        stopButton.disabled = true;
        startPauseButton.innerHTML = '<i class="material-icons">play_circle</i>';
        running = false;
        discardRunButton.disabled = true;
    }

discardRunButton.addEventListener('click', () => {
    createModal(
        'Discard Run',
        '<p>Are you sure you want to clear the current run progress?</p>',
        resetRun
    )
})


function calculateDistance(lat1, lon1, lat2, lon2, unit) {
  const R = 6371; // Earth's radius in kilometers
  const rad = Math.PI / 180; // Convert degrees to radians

  const dLat = rad * (lat2 - lat1);
  const dLon = rad * (lon2 - lon1);

  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(rad * lat1) * Math.cos(rad * lat2) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);

  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  const distance = R * c;

  if (unit === "km") {
    return distance;
  } else if (unit === "mi") {
    return distance * 0.621371; // Convert kilometers to miles
  } else {
    throw new Error("Invalid unit. Please use 'km' or 'mi'.");
  }
}


function calculateTotalDistance(coordinates, unit) {
  if (coordinates.length < 2) {
    throw new Error("Array must contain at least two coordinate pairs.");
  }

  let totalDistance = 0;
  for (let i = 1; i < coordinates.length; i++) {
    const prev = coordinates[i - 1];
    const current = coordinates[i];
    const distance = calculateDistance(prev[0], prev[1], current[0], current[1], unit);
    totalDistance += distance;
  }

  return totalDistance;
}

function plotGpsCoordinatesToSvg(coords) {
  const svgNamespace = "http://www.w3.org/2000/svg";
  let svg = document.getElementById("plot");

  if (!coords || coords.length === 0) return;

  // Clear SVG before drawing
  while (svg.firstChild) {
    svg.removeChild(svg.firstChild);
  }

  let svgWidth = svg.clientWidth;
  let svgHeight = svg.clientHeight;

  let latitudes = coords.map(coord => coord[0]);
  let longitudes = coords.map(coord => coord[1]);

  let minLat = Math.min(...latitudes);
  let maxLat = Math.max(...latitudes);
  let minLon = Math.min(...longitudes);
  let maxLon = Math.max(...longitudes);

  let margin = 0.05;
  let drawableWidth = svgWidth * (1 - 2 * margin);
  let drawableHeight = svgHeight * (1 - 2 * margin);

  let latRange = maxLat - minLat;
  let lonRange = maxLon - minLon;
  let xScale = drawableWidth / lonRange;
  let yScale = drawableHeight / latRange;
  let scale = Math.min(xScale, yScale);

  let xOffset = (svgWidth - lonRange * scale) / 2;
  let yOffset = (svgHeight - latRange * scale) / 2;

  function scaleX(lon) {
    return (lon - minLon) * scale + xOffset;
  }

  function scaleY(lat) {
    return svgHeight - ((lat - minLat) * scale + yOffset);
  }

  let pathData = coords.map((coord, index) => {
    let x = scaleX(coord[1]);
    let y = scaleY(coord[0]);
    return `${index === 0 ? 'M' : 'L'}${x},${y}`;
  }).join(' ');

  let pathElement = document.createElementNS(svgNamespace, 'path');
  pathElement.setAttribute("d", pathData);
  pathElement.setAttribute("stroke", "rgb(0,188,212)");
  pathElement.setAttribute("stroke-width", 6);
  pathElement.setAttribute("fill", "none");
  pathElement.setAttribute("stroke-linejoin", "round");
  pathElement.setAttribute("stroke-linecap", "round");
  svg.appendChild(pathElement);

  // Add a circle at the last point
  let finalPoint = coords[coords.length - 1];
  let circle = document.createElementNS(svgNamespace, 'circle');
  circle.setAttribute("cx", scaleX(finalPoint[1]));
  circle.setAttribute("cy", scaleY(finalPoint[0]));
  circle.setAttribute("r", 5);
  circle.setAttribute("fill", "red");
  svg.appendChild(circle);
}

function generateSmoothPath(startLat, startLon, numPoints) {
    let coords = [];
    let lastDeltaLat = 0;
    let lastDeltaLon = 0;

    for (let i = 0; i < numPoints; i++) {
        // Introduce a small random change to the direction
        let deltaLat = lastDeltaLat + (Math.random() * 0.001 - 0.0005);
        let deltaLon = lastDeltaLon + (Math.random() * 0.001 - 0.0005);

        // Ensure smoothness by limiting how much direction can change
        deltaLat = Math.sign(deltaLat) * Math.min(Math.abs(deltaLat), 0.001);
        deltaLon = Math.sign(deltaLon) * Math.min(Math.abs(deltaLon), 0.001);

        // Update the coordinate
        startLat += deltaLat;
        startLon += deltaLon;

        // Add the new point to the array
        coords.push([startLat, startLon]);

        // Save the deltas for the next iteration
        lastDeltaLat = deltaLat / 2; // Halve the delta to gradually reduce the change
        lastDeltaLon = deltaLon / 2; // This makes the path smoother
    }

    return coords;
}

</script>
